/**
 * GitHub PR Service - Creates PRs for capability changes
 *
 * Uses GitHub API to create branches and pull requests for changes
 * requested through the chat interface.
 */

const https = require('https');
const { createClient } = require('@supabase/supabase-js');

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const REPO_OWNER = process.env.GITHUB_REPO_OWNER || 'JadenLevitt';
const REPO_NAME = process.env.GITHUB_REPO_NAME || 'lagence-platform';

// Supabase for storing proposals
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY
);

/**
 * Classify a user request based on their messages and available capabilities
 */
async function classifyRequest(messages, capabilities, anthropic) {
  const lastUserMessage = messages.filter(m => m.role === 'user').pop();
  if (!lastUserMessage) {
    return { request_type: 'question', can_auto_pr: false };
  }

  const classificationPrompt = `Analyze this user request and classify it.

USER REQUEST: "${lastUserMessage.content}"

AVAILABLE CAPABILITIES:
${JSON.stringify(capabilities.map(c => ({
  id: c.id,
  name: c.name,
  triggers: c.triggers,
  complexity: c.complexity,
  change_types: c.change_types
})), null, 2)}

Respond with JSON only (no markdown, no explanation):
{
  "request_type": "question" | "capability_tweak" | "new_capability",
  "matched_capability_id": "string or null",
  "complexity": "low" | "medium" | "high",
  "change_description": "brief description of what needs to change",
  "affected_files": ["array of likely file paths"],
  "can_auto_pr": true/false (true for low/medium complexity tweaks, false otherwise),
  "requires_plan_approval": true/false (true for new capabilities or high complexity)
}`;

  try {
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1024,
      messages: [{ role: 'user', content: classificationPrompt }]
    });

    const text = response.content[0].text.trim();
    // Extract JSON from response (handle potential markdown wrapping)
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    return { request_type: 'question', can_auto_pr: false };
  } catch (err) {
    console.error('Classification error:', err.message);
    return { request_type: 'question', can_auto_pr: false };
  }
}

/**
 * Make a GitHub API request
 */
function githubAPI(method, path, body = null) {
  return new Promise((resolve, reject) => {
    if (!GITHUB_TOKEN) {
      reject(new Error('GITHUB_TOKEN not configured'));
      return;
    }

    const options = {
      hostname: 'api.github.com',
      path: path,
      method: method,
      headers: {
        'Authorization': `Bearer ${GITHUB_TOKEN}`,
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'LAGENCE-Platform',
        'Content-Type': 'application/json'
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          try {
            resolve(JSON.parse(data));
          } catch {
            resolve(data);
          }
        } else {
          reject(new Error(`GitHub API error: ${res.statusCode} - ${data}`));
        }
      });
    });

    req.on('error', reject);
    if (body) req.write(JSON.stringify(body));
    req.end();
  });
}

/**
 * Create a PR for a capability change
 */
async function createCapabilityPR(change, agentId) {
  const branchName = `capability/${agentId}-${change.matched_capability_id || 'update'}-${Date.now()}`;

  try {
    // 1. Get current main branch SHA
    const mainRef = await githubAPI('GET', `/repos/${REPO_OWNER}/${REPO_NAME}/git/ref/heads/main`);
    const baseSha = mainRef.object.sha;

    // 2. Create new branch
    await githubAPI('POST', `/repos/${REPO_OWNER}/${REPO_NAME}/git/refs`, {
      ref: `refs/heads/${branchName}`,
      sha: baseSha
    });

    // 3. Create PR (without actual file changes for now - those would be added by the code generation step)
    const pr = await githubAPI('POST', `/repos/${REPO_OWNER}/${REPO_NAME}/pulls`, {
      title: `[${agentId}] ${change.change_description}`,
      body: `## Change Request from Chat Assistant

**Agent:** ${agentId}
**Capability:** ${change.matched_capability_id || 'N/A'}
**Complexity:** ${change.complexity}
**Type:** ${change.request_type}

### Description
${change.change_description}

### Affected Files
${change.affected_files?.map(f => `- \`${f}\``).join('\n') || '- To be determined'}

---
*Auto-generated by L'AGENCE Platform*
*Review and add the actual code changes to this branch*`,
      head: branchName,
      base: 'main',
      draft: true // Create as draft since code changes need to be added
    });

    // 4. Log to Supabase
    await supabase.from('feature_requests').insert({
      agent_id: agentId,
      conversation: [],
      assistant_response: `PR created: ${pr.html_url}`,
      classification: change,
      action_taken: { type: 'pr_created', pr_url: pr.html_url, pr_number: pr.number },
      status: 'in_progress'
    }).catch(err => console.error('Failed to log to Supabase:', err.message));

    return {
      success: true,
      pr_url: pr.html_url,
      pr_number: pr.number,
      branch: branchName
    };
  } catch (err) {
    console.error('Failed to create PR:', err.message);
    return {
      success: false,
      error: err.message
    };
  }
}

/**
 * Create a plan proposal for high-complexity changes
 */
async function createPlanProposal(proposal, agentId) {
  try {
    const { data, error } = await supabase
      .from('capability_proposals')
      .insert({
        agent_id: agentId,
        title: proposal.title,
        description: proposal.description,
        complexity: 'high',
        status: 'pending_approval',
        proposed_changes: proposal.changes
      })
      .select()
      .single();

    if (error) throw error;

    return {
      success: true,
      proposal_id: data.id
    };
  } catch (err) {
    console.error('Failed to create proposal:', err.message);
    return {
      success: false,
      error: err.message
    };
  }
}

/**
 * Get pending proposals for an agent
 */
async function getPendingProposals(agentId) {
  try {
    const { data, error } = await supabase
      .from('capability_proposals')
      .select('*')
      .eq('agent_id', agentId)
      .eq('status', 'pending_approval')
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data || [];
  } catch (err) {
    console.error('Failed to get proposals:', err.message);
    return [];
  }
}

/**
 * Approve a proposal and create a PR for it
 */
async function approveProposal(proposalId) {
  try {
    // Get the proposal
    const { data: proposal, error: getError } = await supabase
      .from('capability_proposals')
      .select('*')
      .eq('id', proposalId)
      .single();

    if (getError) throw getError;

    // Create a PR for it
    const pr = await createCapabilityPR({
      matched_capability_id: 'new-capability',
      change_description: proposal.title,
      complexity: 'high',
      affected_files: proposal.proposed_changes?.files || []
    }, proposal.agent_id);

    // Update proposal status
    await supabase
      .from('capability_proposals')
      .update({
        status: 'approved',
        pr_url: pr.pr_url
      })
      .eq('id', proposalId);

    return {
      success: true,
      pr_url: pr.pr_url
    };
  } catch (err) {
    console.error('Failed to approve proposal:', err.message);
    return {
      success: false,
      error: err.message
    };
  }
}

module.exports = {
  classifyRequest,
  createCapabilityPR,
  createPlanProposal,
  getPendingProposals,
  approveProposal,
  githubAPI
};
